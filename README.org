* Learning SICP
  Notes and answer to exercises from SICP.
  
* Metadata
  | Start Date       | Current Date     | Days Elapsed |
  |------------------+------------------+--------------|
  | [2014-11-21 Fri] | [2014-11-24 Mon] |            3 |
  #+TBLFM: $3 = $2 - $1

* Log
#+BEGIN: clocktable :maxlevel 2 :scope subtree
#+CAPTION: Clock summary at [2014-11-24 Mon 06:30]
| Headline                                    | Time   |      |
|---------------------------------------------+--------+------|
| *Total time*                                | *1:00* |      |
|---------------------------------------------+--------+------|
| Log                                         | 1:00   |      |
| \emsp DONE Frontmatter [100%]               |        | 0:30 |
| \emsp TODO 1  Building Abstractions with... |        | 0:30 |
#+END:

** DONE Frontmatter [100%]
   CLOCK: [2014-11-21 Fri 06:46]--[2014-11-21 Fri 07:16] =>  0:30

** TODO 1  Building Abstractions with Procedures [0%]
*** TODO 1.1  The Elements of Programming
    CLOCK: [2014-11-24 Mon 05:38]--[2014-11-24 Mon 06:08] =>  0:30
**** TODO 1.1.1  Expressions
     CLOCK: [2014-11-24 Mon 06:34]

**** TODO 1.1.2  Naming and the Environment
**** TODO 1.1.3  Evaluating Combinations
**** TODO 1.1.4  Compound Procedures
**** TODO 1.1.5  The Substitution Model for Procedure Application
**** TODO 1.1.6  Conditional Expressions and Predicates
**** TODO 1.1.7  Example: Square Roots by Newton's Method
**** TODO 1.1.8  Procedures as Black-Box Abstractions
*** TODO 1.2  Procedures and the Processes They Generate
**** TODO 1.2.1  Linear Recursion and Iteration
**** TODO 1.2.2  Tree Recursion
**** TODO 1.2.3  Orders of Growth
**** TODO 1.2.4  Exponentiation
**** TODO 1.2.5  Greatest Common Divisors
**** TODO 1.2.6  Example: Testing for Primality
*** TODO 1.3  Formulating Abstractions with Higher-Order Procedures
**** TODO 1.3.1  Procedures as Arguments
**** TODO 1.3.2  Constructing Procedures Using Lambda
**** TODO 1.3.3  Procedures as General Methods
**** TODO 1.3.4  Procedures as Returned Values
** TODO 2  Building Abstractions with Data
*** TODO 2.1  Introduction to Data Abstraction
**** TODO 2.1.1  Example: Arithmetic Operations for Rational Numbers
**** TODO 2.1.2  Abstraction Barriers
**** TODO 2.1.3  What Is Meant by Data?
**** TODO 2.1.4  Extended Exercise: Interval Arithmetic
*** TODO 2.2  Hierarchical Data and the Closure Property
**** TODO 2.2.1  Representing Sequences
**** TODO 2.2.2  Hierarchical Structures
**** TODO 2.2.3  Sequences as Conventional Interfaces
**** TODO 2.2.4  Example: A Picture Language
*** TODO 2.3  Symbolic Data
**** TODO 2.3.1  Quotation
**** TODO 2.3.2  Example: Symbolic Differentiation
**** TODO 2.3.3  Example: Representing Sets
**** TODO 2.3.4  Example: Huffman Encoding Trees
*** TODO 2.4  Multiple Representations for Abstract Data
**** TODO 2.4.1  Representations for Complex Numbers
**** TODO 2.4.2  Tagged data
**** TODO 2.4.3  Data-Directed Programming and Additivity
*** TODO 2.5  Systems with Generic Operations
**** TODO 2.5.1  Generic Arithmetic Operations
**** TODO 2.5.2  Combining Data of Different Types
**** TODO 2.5.3  Example: Symbolic Algebra
** TODO 3  Modularity, Objects, and State
*** TODO 3.1  Assignment and Local State
**** TODO 3.1.1  Local State Variables
**** TODO 3.1.2  The Benefits of Introducing Assignment
**** TODO 3.1.3  The Costs of Introducing Assignment
*** TODO 3.2  The Environment Model of Evaluation
**** TODO 3.2.1  The Rules for Evaluation
**** TODO 3.2.2  Applying Simple Procedures
**** TODO 3.2.3  Frames as the Repository of Local State
**** TODO 3.2.4  Internal Definitions
*** TODO 3.3  Modeling with Mutable Data
**** TODO 3.3.1  Mutable List Structure
**** TODO 3.3.2  Representing Queues
**** TODO 3.3.3  Representing Tables
**** TODO 3.3.4  A Simulator for Digital Circuits
**** TODO 3.3.5  Propagation of Constraints
*** TODO 3.4  Concurrency: Time Is of the Essence
**** TODO 3.4.1  The Nature of Time in Concurrent Systems
**** TODO 3.4.2  Mechanisms for Controlling Concurrency
*** TODO 3.5  Streams
**** TODO 3.5.1  Streams Are Delayed Lists
**** TODO 3.5.2  Infinite Streams
**** TODO 3.5.3  Exploiting the Stream Paradigm
**** TODO 3.5.4  Streams and Delayed Evaluation
**** TODO 3.5.5  Modularity of Functional Programs and Modularity of Objects
** TODO 4  Metalinguistic Abstraction
*** TODO 4.1  The Metacircular Evaluator
**** TODO 4.1.1  The Core of the Evaluator
**** TODO 4.1.2  Representing Expressions
**** TODO 4.1.3  Evaluator Data Structures
**** TODO 4.1.4  Running the Evaluator as a Program
**** TODO 4.1.5  Data as Programs
**** TODO 4.1.6  Internal Definitions
**** TODO 4.1.7  Separating Syntactic Analysis from Execution
*** TODO 4.2  Variations on a Scheme -- Lazy Evaluation
**** TODO 4.2.1  Normal Order and Applicative Order
**** TODO 4.2.2  An Interpreter with Lazy Evaluation
**** TODO 4.2.3  Streams as Lazy Lists
*** TODO 4.3  Variations on a Scheme -- Nondeterministic Computing
**** TODO 4.3.1  Amb and Search
**** TODO 4.3.2  Examples of Nondeterministic Programs
**** TODO 4.3.3  Implementing the Amb Evaluator
*** TODO 4.4  Logic Programming
**** TODO 4.4.1  Deductive Information Retrieval
**** TODO 4.4.2  How the Query System Works
**** TODO 4.4.3  Is Logic Programming Mathematical Logic?
**** TODO 4.4.4  Implementing the Query System
** TODO 5  Computing with Register Machines
*** TODO 5.1  Designing Register Machines
**** TODO 5.1.1  A Language for Describing Register Machines
**** TODO 5.1.2  Abstraction in Machine Design
**** TODO 5.1.3  Subroutines
**** TODO 5.1.4  Using a Stack to Implement Recursion
**** TODO 5.1.5  Instruction Summary
*** TODO 5.2  A Register-Machine Simulator
**** TODO 5.2.1  The Machine Model
**** TODO 5.2.2  The Assembler
**** TODO 5.2.3  Generating Execution Procedures for Instructions
**** TODO 5.2.4  Monitoring Machine Performance
*** TODO 5.3  Storage Allocation and Garbage Collection
**** TODO 5.3.1  Memory as Vectors
**** TODO 5.3.2  Maintaining the Illusion of Infinite Memory
*** TODO 5.4  The Explicit-Control Evaluator
**** TODO 5.4.1  The Core of the Explicit-Control Evaluator
**** TODO 5.4.2  Sequence Evaluation and Tail Recursion
**** TODO 5.4.3  Conditionals, Assignments, and Definitions
**** TODO 5.4.4  Running the Evaluator
*** TODO 5.5  Compilation
**** TODO 5.5.1  Structure of the Compiler
**** TODO 5.5.2  Compiling Expressions
**** TODO 5.5.3  Compiling Combinations
**** TODO 5.5.4  Combining Instruction Sequences
**** TODO 5.5.5  An Example of Compiled Code
**** TODO 5.5.6  Lexical Addressing
**** TODO 5.5.7  Interfacing Compiled Code to the Evaluator
     


